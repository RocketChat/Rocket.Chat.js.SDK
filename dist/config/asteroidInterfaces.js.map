{"version":3,"file":"asteroidInterfaces.js","sourceRoot":"","sources":["../../src/config/asteroidInterfaces.ts"],"names":[],"mappings":"","sourcesContent":["import { EventEmitter } from 'events'\n// import { Map } from 'immutable'\n\n/**\n * Asteroid DDP - add known properties to avoid TS lint errors\n */\nexport interface IAsteroidDDP extends EventEmitter {\n  readyState: 1 | 0\n}\n\n/**\n * Asteroid type\n * @todo Update with typing from definitely typed (when available)\n */\nexport interface IAsteroid extends EventEmitter {\n  connect: () => Promise<void>,\n  disconnect: () => Promise<void>,\n  createUser: (usernameOrEmail: string, password: string, profile: IUserOptions) => Promise<any>\n  loginWithLDAP: (...params: any[]) => Promise<any>\n  loginWithFacebook: (...params: any[]) => Promise<any>\n  loginWithGoogle: (...params: any[]) => Promise<any>\n  loginWithTwitter: (...params: any[]) => Promise<any>\n  loginWithGithub: (...params: any[]) => Promise<any>\n  loginWithPassword: (usernameOrEmail: string, password: string) => Promise<any>\n  logout: () => Promise<null>\n  subscribe: (name: string, ...params: any[]) => ISubscription\n  subscriptions: ISubscription[],\n  call: (method: string, ...params: any[]) => IMethodResult\n  apply: (method: string, params: any[]) => IMethodResult\n  getCollection: (name: string) => ICollection\n  resumeLoginPromise: Promise<string>\n  ddp: IAsteroidDDP\n}\n\n/**\n * Asteroid user options type\n * @todo Update with typing from definitely typed (when available)\n */\nexport interface IUserOptions {\n  username?: string,\n  email?: string,\n  password: string\n}\n\n/**\n * Asteroid subscription type.\n * ID is populated when ready promise resolves.\n * @todo Update with typing from definitely typed (when available)\n */\nexport interface ISubscription {\n  stop: () => void,\n  ready: Promise<IReady>,\n  id?: string\n}\n\n// Asteroid v1 only\nexport interface IReady { state: string, value: string }\n\n/* // v2\nexport interface ISubscription extends EventEmitter {\n  id: string\n}\n*/\n\n/**\n * If the method is successful, the `result` promise will be resolved with the\n * return value passed by the server. The `updated` promise will be resolved\n * with nothing once the server emits the updated message, that tells the client\n * that any side-effect that the method execution caused on the database has\n * been reflected on the client (for example, if the method caused the insertion\n * of an item into a collection, the client has been notified of said\n * insertion).\n *\n * If the method fails, the `result` promise will be rejected with the error\n * returned by the server. The `updated` promise will be rejected as well\n * (with nothing).\n */\nexport interface IMethodResult {\n  result: Promise<any>,\n  updated: Promise<any>\n}\n\n/**\n *\n */\nexport interface ICollection {\n  name: string,\n  insert: (item: any) => ICollectionResult,\n  update: (id: string, item: any) => ICollectionResult,\n  remove: (id: string) => ICollectionResult,\n  reactiveQuery: (selector: object | Function) => IReactiveQuery\n}\n\n/**\n * The `local` promise is immediately resolved with the `_id` of the updated\n * item. That is, unless an error occurred. In that case, an exception will be\n * raised.\n * The `remote` promise is resolved with the `_id` of the updated item if the\n * remote update is successful. Otherwise it's rejected with the reason of the\n * failure.\n */\nexport interface ICollectionResult {\n  local: Promise<any>,\n  remote: Promise<any>\n}\n\n/**\n * A reactive subset of a collection. Possible events are:\n * `change`: emitted whenever the result of the query changes. The id of the\n * item that changed is passed to the handler.\n */\nexport interface IReactiveQuery {\n  on: (event: string, handler: Function) => void,\n  result: any[]\n}\n\n/** Credentials for Asteroid login method */\nexport interface ICredentials {\n  password: string,\n  username?: string,\n  email?: string,\n  ldap?: boolean,\n  ldapOptions?: object\n}\n"]}